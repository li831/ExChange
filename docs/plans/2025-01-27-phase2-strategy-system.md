# Phase 2: Pine Scriptç­–ç•¥ç³»ç»Ÿ å®æ–½è®¡åˆ’

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** å®ç°Pine Script DSLè§£æå™¨ï¼Œæ„å»ºçµæ´»çš„ç­–ç•¥ç³»ç»Ÿï¼Œæ”¯æŒFreqtradeç­–ç•¥è½¬æ¢

**Architecture:** Pestè§£æå™¨ï¼ŒASTæ‰§è¡Œå™¨ï¼ŒæŠ€æœ¯æŒ‡æ ‡åº“ï¼Œç­–ç•¥çƒ­åŠ è½½ï¼ŒFreqtradeé›†æˆ

**Tech Stack:** Rust 1.75+, Pest, Freqtrade, Python ASTåˆ†æ

---

## ğŸ“Š å®æ–½è¿›åº¦ (å¼€å§‹æ—¶é—´: 2025-01-27)

### æ€»ä½“è¿›åº¦: 3/14 ä»»åŠ¡å®Œæˆ (21%)

| Task | çŠ¶æ€ | é¢„è®¡å¤©æ•° | æµ‹è¯•æ•°é‡ | Git Commit |
|------|------|----------|----------|------------|
| Task 1: DSLè¯­æ³•å®šä¹‰ | âœ… å·²å®Œæˆ | 2å¤© | - | 088256e |
| Task 2: è¯æ³•åˆ†æå™¨ | âœ… å·²å®Œæˆ | 1.5å¤© | 6ä¸ª | e0de6ec |
| Task 3: ASTç”Ÿæˆå™¨ | âœ… å·²å®Œæˆ | 1.5å¤© | 8ä¸ª | 5dc24cf |
| Task 4: åŸºç¡€æŒ‡æ ‡å®ç° | â³ å¾…å¼€å§‹ | 2å¤© | - | - |
| Task 5: æŒ‡æ ‡æ³¨å†Œç³»ç»Ÿ | â³ å¾…å¼€å§‹ | 1å¤© | - | - |
| Task 6: æŒ‡æ ‡ç¼“å­˜ä¼˜åŒ– | â³ å¾…å¼€å§‹ | 1å¤© | - | - |
| Task 7: ASTæ‰§è¡Œå™¨ | â³ å¾…å¼€å§‹ | 2å¤© | - | - |
| Task 8: ç­–ç•¥å‡½æ•°å®ç° | â³ å¾…å¼€å§‹ | 1.5å¤© | - | - |
| Task 9: å†…ç½®å‡½æ•°åº“ | â³ å¾…å¼€å§‹ | 1.5å¤© | - | - |
| Task 10: Freqtradeç¯å¢ƒ | â³ å¾…å¼€å§‹ | 0.5å¤© | - | - |
| Task 11: ç­–ç•¥è½¬æ¢å™¨ | â³ å¾…å¼€å§‹ | 2å¤© | - | - |
| Task 12: å›æµ‹ä¸€è‡´æ€§éªŒè¯ | â³ å¾…å¼€å§‹ | 1.5å¤© | - | - |
| Task 13: ç­–ç•¥çƒ­åŠ è½½ | â³ å¾…å¼€å§‹ | 1å¤© | - | - |
| Task 14: å¤šç­–ç•¥ç®¡ç† | â³ å¾…å¼€å§‹ | 1å¤© | - | - |

### å…³é”®æŒ‡æ ‡
- **ç›®æ ‡æµ‹è¯•æ•°**: 100+ å•å…ƒæµ‹è¯• (å½“å‰: 14ä¸ª)
- **DSLè¦†ç›–åº¦**: Pine Script v5æ ¸å¿ƒåŠŸèƒ½çš„60% (å½“å‰: è¯­æ³•è§£æå®Œæˆ)
- **å›æµ‹ä¸€è‡´æ€§**: ä¸Freqtradeä¿¡å·ä¸€è‡´æ€§>95% (å¾…å®ç°)
- **æ€§èƒ½ç›®æ ‡**: 1000æ•°æ®ç‚¹æŒ‡æ ‡è®¡ç®—<1ms (å¾…æµ‹è¯•)
- **å¼€å‘æ–¹æ³•**: TDD + å¢é‡é›†æˆ âœ…

---

## Task 1: Pine Script DSLè¯­æ³•å®šä¹‰

**Goal:** å®šä¹‰æ”¯æŒçš„Pine Scriptè¯­æ³•å­é›†ï¼Œåˆ›å»ºBNFè§„èŒƒ

**Files:**
- Create: `trading-engine/docs/pine-script-spec.md`
- Create: `trading-engine/examples/strategies/`
- Create: `trading-engine/examples/strategies/simple_ma.pine`
- Create: `trading-engine/examples/strategies/bollinger_bands.pine`
- Create: `trading-engine/examples/strategies/rsi_strategy.pine`

### Step 1: ç ”ç©¶Pine Script v5æ ¸å¿ƒè¯­æ³•

**åˆ†æå†…å®¹:**
- å˜é‡å£°æ˜å’Œèµ‹å€¼
- æŠ€æœ¯æŒ‡æ ‡å‡½æ•°
- æ¡ä»¶è¯­å¥
- ç­–ç•¥å‡½æ•°
- å†…ç½®å˜é‡

**åˆ›å»ºæ–‡ä»¶: `docs/pine-script-spec.md`**

```markdown
# Pine Script DSL è¯­æ³•è§„èŒƒ

## 1. æ”¯æŒçš„è¯­æ³•å…ƒç´ 

### 1.1 å˜é‡å£°æ˜
```pine
// ç®€å•èµ‹å€¼
length = 20
price = close

// è¾“å…¥å‚æ•°
length = input(20, "Period")
multiplier = input.float(2.0, "Multiplier", step=0.1)
```

### 1.2 æŠ€æœ¯æŒ‡æ ‡å‡½æ•°
```pine
// ç§»åŠ¨å¹³å‡
sma_value = ta.sma(close, length)
ema_value = ta.ema(close, length)

// RSI
rsi_value = ta.rsi(close, 14)

// MACD
[macd_line, signal_line, histogram] = ta.macd(close, 12, 26, 9)

// å¸ƒæ—å¸¦
[middle, upper, lower] = ta.bb(close, 20, 2.0)
```

### 1.3 æ¡ä»¶è¯­å¥
```pine
if condition
    action()
else if other_condition
    other_action()
else
    default_action()
```

### 1.4 ç­–ç•¥å‡½æ•°
```pine
strategy("My Strategy", overlay=true)
strategy.entry("Long", strategy.long)
strategy.close("Long")
strategy.exit("Stop Loss", "Long", stop=stop_price)
```

## 2. BNFè¯­æ³•è§„èŒƒ

```bnf
<strategy> ::= <strategy_declaration> <statement_list>

<strategy_declaration> ::= "strategy" "(" <string> <parameters>? ")"

<statement_list> ::= <statement> | <statement> <statement_list>

<statement> ::= <assignment>
              | <if_statement>
              | <strategy_call>
              | <expression>

<assignment> ::= <identifier> "=" <expression>

<if_statement> ::= "if" <condition> <block> <else_clause>?

<else_clause> ::= "else" "if" <condition> <block> <else_clause>?
                | "else" <block>

<expression> ::= <literal>
               | <identifier>
               | <function_call>
               | <binary_operation>
               | <array_access>

<function_call> ::= <identifier> "(" <argument_list>? ")"
                  | <namespace> "." <identifier> "(" <argument_list>? ")"

<namespace> ::= "ta" | "strategy" | "input" | "math"

<binary_operation> ::= <expression> <operator> <expression>

<operator> ::= "+" | "-" | "*" | "/" | ">" | "<" | ">=" | "<=" | "==" | "!=" | "and" | "or"
```
```

### Step 2: åˆ›å»ºç¤ºä¾‹ç­–ç•¥æ–‡ä»¶

**æ–‡ä»¶: `examples/strategies/simple_ma.pine`**

```pine
//@version=5
strategy("Simple Moving Average", overlay=true)

// è¾“å…¥å‚æ•°
fast_length = input(5, "Fast MA Period")
slow_length = input(20, "Slow MA Period")

// è®¡ç®—ç§»åŠ¨å¹³å‡
fast_ma = ta.sma(close, fast_length)
slow_ma = ta.sma(close, slow_length)

// ç”Ÿæˆä¿¡å·
long_condition = ta.crossover(fast_ma, slow_ma)
short_condition = ta.crossunder(fast_ma, slow_ma)

// æ‰§è¡Œäº¤æ˜“
if long_condition
    strategy.entry("Long", strategy.long)

if short_condition
    strategy.close("Long")
```

**æ–‡ä»¶: `examples/strategies/bollinger_bands.pine`**

```pine
//@version=5
strategy("Bollinger Bands Mean Reversion", overlay=true)

// è¾“å…¥å‚æ•°
bb_length = input(20, "BB Length")
bb_mult = input.float(2.0, "BB StdDev")
rsi_period = input(14, "RSI Period")
rsi_oversold = input(30, "RSI Oversold")
rsi_overbought = input(70, "RSI Overbought")

// è®¡ç®—æŒ‡æ ‡
[middle, upper, lower] = ta.bb(close, bb_length, bb_mult)
rsi = ta.rsi(close, rsi_period)

// å…¥åœºæ¡ä»¶
long_entry = close < lower and rsi < rsi_oversold
short_entry = close > upper and rsi > rsi_overbought

// å‡ºåœºæ¡ä»¶
long_exit = close > middle
short_exit = close < middle

// æ‰§è¡Œç­–ç•¥
if long_entry
    strategy.entry("BBLong", strategy.long)

if long_exit
    strategy.close("BBLong")

if short_entry
    strategy.entry("BBShort", strategy.short)

if short_exit
    strategy.close("BBShort")
```

### Step 3: éªŒè¯è¯­æ³•è¦†ç›–åº¦

**æ£€æŸ¥æ¸…å•:**
- [ ] å˜é‡èµ‹å€¼
- [ ] è¾“å…¥å‚æ•°å®šä¹‰
- [ ] æŠ€æœ¯æŒ‡æ ‡è°ƒç”¨
- [ ] æ¡ä»¶åˆ¤æ–­
- [ ] ç­–ç•¥å…¥åœº/å‡ºåœº
- [ ] æ•°å­¦è¿ç®—
- [ ] é€»è¾‘è¿ç®—
- [ ] æ¯”è¾ƒè¿ç®—

### Step 4: æäº¤è¯­æ³•è§„èŒƒ

**å‘½ä»¤:**
```bash
git add docs/pine-script-spec.md examples/strategies/
git commit -m "feat: define Pine Script DSL syntax specification"
```

---

## Task 2: è¯æ³•åˆ†æå™¨å®ç° (Pest)

**Goal:** ä½¿ç”¨Pestè§£æå™¨ç”Ÿæˆå™¨å®ç°è¯æ³•åˆ†æ

**Files:**
- Create: `trading-engine/src/strategy/parser/mod.rs`
- Create: `trading-engine/src/strategy/parser/pine.pest`
- Create: `trading-engine/tests/parser_test.rs`
- Modify: `trading-engine/Cargo.toml`

### Step 1: æ·»åŠ Pestä¾èµ–

**æ–‡ä»¶: `Cargo.toml`**

```toml
[dependencies]
# è§£æå™¨
pest = "2.7"
pest_derive = "2.7"

[dev-dependencies]
pretty_assertions = "1.4"
```

### Step 2: ç¼–å†™Pestè¯­æ³•æ–‡ä»¶

**æ–‡ä»¶: `src/strategy/parser/pine.pest`**

```pest
// Pine Script Grammar

WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* }

// ä¸»è§„åˆ™
strategy = { SOI ~ strategy_declaration ~ statement* ~ EOI }

strategy_declaration = {
    "strategy" ~ "(" ~ string ~ ("," ~ parameter)* ~ ")"
}

parameter = { identifier ~ "=" ~ value }

statement = {
    assignment
  | if_statement
  | strategy_call
  | expression
}

// èµ‹å€¼è¯­å¥
assignment = { identifier ~ "=" ~ expression }

// æ¡ä»¶è¯­å¥
if_statement = {
    "if" ~ condition ~ block ~ else_clause?
}

else_clause = {
    "else" ~ "if" ~ condition ~ block ~ else_clause?
  | "else" ~ block
}

block = { statement+ | "{" ~ statement* ~ "}" }

condition = { expression }

// ç­–ç•¥è°ƒç”¨
strategy_call = {
    "strategy" ~ "." ~ identifier ~ "(" ~ argument_list? ~ ")"
}

// è¡¨è¾¾å¼
expression = { term ~ (binary_op ~ term)* }

term = {
    literal
  | function_call
  | identifier
  | array_destructure
  | "(" ~ expression ~ ")"
}

// å‡½æ•°è°ƒç”¨
function_call = {
    namespace ~ "." ~ identifier ~ "(" ~ argument_list? ~ ")"
  | identifier ~ "(" ~ argument_list? ~ ")"
}

namespace = { "ta" | "strategy" | "input" | "math" }

argument_list = { expression ~ ("," ~ expression)* }

// æ•°ç»„è§£æ„
array_destructure = {
    "[" ~ identifier ~ ("," ~ identifier)* ~ "]"
}

// è¿ç®—ç¬¦
binary_op = {
    comparison_op
  | arithmetic_op
  | logical_op
}

comparison_op = { ">=" | "<=" | ">" | "<" | "==" | "!=" }
arithmetic_op = { "+" | "-" | "*" | "/" | "%" }
logical_op = { "and" | "or" }

// å­—é¢é‡
literal = {
    float_literal
  | integer_literal
  | boolean_literal
  | string
}

float_literal = @{ integer ~ "." ~ ASCII_DIGIT+ }
integer_literal = @{ "-"? ~ ASCII_DIGIT+ }
boolean_literal = { "true" | "false" }
string = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }

// æ ‡è¯†ç¬¦
identifier = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }

// å†…ç½®å˜é‡
builtin_var = {
    "close" | "open" | "high" | "low" | "volume" | "time"
}

value = { literal | identifier }
```

### Step 3: å®ç°è§£æå™¨æ¨¡å—

**æ–‡ä»¶: `src/strategy/parser/mod.rs`**

```rust
use pest::Parser;
use pest_derive::Parser;
use anyhow::{Result, Context};

#[derive(Parser)]
#[grammar = "strategy/parser/pine.pest"]
pub struct PineScriptParser;

pub fn parse_strategy(input: &str) -> Result<pest::iterators::Pairs<Rule>> {
    PineScriptParser::parse(Rule::strategy, input)
        .context("Failed to parse Pine Script strategy")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_simple_assignment() {
        let input = "strategy(\"Test\")
length = 20";
        let result = parse_strategy(input);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_function_call() {
        let input = "strategy(\"Test\")
sma_value = ta.sma(close, 20)";
        let result = parse_strategy(input);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_if_statement() {
        let input = "strategy(\"Test\")
if close > open
    strategy.entry(\"Long\", strategy.long)";
        let result = parse_strategy(input);
        assert!(result.is_ok());
    }
}
```

### Step 4: ç¼–å†™è§£æå™¨æµ‹è¯•

**æ–‡ä»¶: `tests/parser_test.rs`**

```rust
use trading_engine::strategy::parser::parse_strategy;

#[test]
fn test_parse_complete_strategy() {
    let strategy = r#"
strategy("Dual MA Strategy", overlay=true)

fast_length = input(5, "Fast Period")
slow_length = input(20, "Slow Period")

fast_ma = ta.sma(close, fast_length)
slow_ma = ta.sma(close, slow_length)

if ta.crossover(fast_ma, slow_ma)
    strategy.entry("Long", strategy.long)

if ta.crossunder(fast_ma, slow_ma)
    strategy.close("Long")
"#;

    let result = parse_strategy(strategy);
    assert!(result.is_ok(), "Failed to parse complete strategy");
}

#[test]
fn test_parse_array_destructure() {
    let strategy = r#"
strategy("BB Strategy")
[middle, upper, lower] = ta.bb(close, 20, 2.0)
"#;

    let result = parse_strategy(strategy);
    assert!(result.is_ok(), "Failed to parse array destructuring");
}

#[test]
fn test_parse_nested_conditions() {
    let strategy = r#"
strategy("Complex Strategy")
if rsi < 30
    if volume > ta.sma(volume, 20)
        strategy.entry("Long", strategy.long)
    else
        strategy.close("Long")
"#;

    let result = parse_strategy(strategy);
    assert!(result.is_ok(), "Failed to parse nested conditions");
}
```

### Step 5: è¿è¡Œæµ‹è¯•éªŒè¯è§£æå™¨

**å‘½ä»¤:**
```bash
cargo test test_parse
```

**æœŸæœ›è¾“å‡º:**
```
test tests::parser_test::test_parse_complete_strategy ... ok
test tests::parser_test::test_parse_array_destructure ... ok
test tests::parser_test::test_parse_nested_conditions ... ok
```

### Step 6: æäº¤è¯æ³•åˆ†æå™¨

**å‘½ä»¤:**
```bash
git add src/strategy/parser/ tests/parser_test.rs Cargo.toml
git commit -m "feat: implement Pine Script lexer using Pest parser"
```

---

## Task 3: AST (æŠ½è±¡è¯­æ³•æ ‘) ç”Ÿæˆå™¨

**Goal:** å°†Pestè§£æç»“æœè½¬æ¢ä¸ºç±»å‹åŒ–çš„AST

**Files:**
- Create: `trading-engine/src/strategy/ast.rs`
- Create: `trading-engine/src/strategy/ast_builder.rs`
- Create: `tests/ast_test.rs`
- Modify: `src/strategy/mod.rs`

### Step 1: å®šä¹‰ASTèŠ‚ç‚¹ç±»å‹

**æ–‡ä»¶: `src/strategy/ast.rs`**

```rust
use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq)]
pub struct Strategy {
    pub name: String,
    pub parameters: HashMap<String, Value>,
    pub statements: Vec<Statement>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum Statement {
    Assignment {
        target: AssignmentTarget,
        value: Expression,
    },
    If {
        condition: Expression,
        then_block: Vec<Statement>,
        else_block: Option<Vec<Statement>>,
    },
    StrategyCall {
        function: String,
        arguments: Vec<Expression>,
    },
    Expression(Expression),
}

#[derive(Debug, Clone, PartialEq)]
pub enum AssignmentTarget {
    Variable(String),
    ArrayDestructure(Vec<String>),
}

#[derive(Debug, Clone, PartialEq)]
pub enum Expression {
    Literal(Value),
    Variable(String),
    FunctionCall {
        namespace: Option<String>,
        name: String,
        arguments: Vec<Expression>,
    },
    BinaryOp {
        left: Box<Expression>,
        op: BinaryOperator,
        right: Box<Expression>,
    },
    ArrayAccess {
        array: Box<Expression>,
        index: Box<Expression>,
    },
}

#[derive(Debug, Clone, PartialEq)]
pub enum Value {
    Integer(i64),
    Float(f64),
    Boolean(bool),
    String(String),
    Array(Vec<Value>),
}

#[derive(Debug, Clone, PartialEq)]
pub enum BinaryOperator {
    // ç®—æœ¯
    Add, Subtract, Multiply, Divide, Modulo,
    // æ¯”è¾ƒ
    Greater, Less, GreaterEqual, LessEqual, Equal, NotEqual,
    // é€»è¾‘
    And, Or,
}

impl BinaryOperator {
    pub fn from_str(s: &str) -> Option<Self> {
        use BinaryOperator::*;
        match s {
            "+" => Some(Add),
            "-" => Some(Subtract),
            "*" => Some(Multiply),
            "/" => Some(Divide),
            "%" => Some(Modulo),
            ">" => Some(Greater),
            "<" => Some(Less),
            ">=" => Some(GreaterEqual),
            "<=" => Some(LessEqual),
            "==" => Some(Equal),
            "!=" => Some(NotEqual),
            "and" => Some(And),
            "or" => Some(Or),
            _ => None,
        }
    }
}
```

### Step 2: å®ç°ASTæ„å»ºå™¨

**æ–‡ä»¶: `src/strategy/ast_builder.rs`**

```rust
use super::ast::*;
use super::parser::{PineScriptParser, Rule};
use pest::iterators::{Pair, Pairs};
use pest::Parser;
use anyhow::{Result, anyhow, Context};

pub struct ASTBuilder;

impl ASTBuilder {
    pub fn build(input: &str) -> Result<Strategy> {
        let pairs = PineScriptParser::parse(Rule::strategy, input)
            .context("Failed to parse Pine Script")?;

        let strategy_pair = pairs.into_iter().next()
            .ok_or_else(|| anyhow!("No strategy found"))?;

        Self::build_strategy(strategy_pair)
    }

    fn build_strategy(pair: Pair<Rule>) -> Result<Strategy> {
        let mut name = String::new();
        let mut parameters = HashMap::new();
        let mut statements = Vec::new();

        for inner in pair.into_inner() {
            match inner.as_rule() {
                Rule::strategy_declaration => {
                    let (n, p) = Self::build_strategy_declaration(inner)?;
                    name = n;
                    parameters = p;
                }
                Rule::statement => {
                    statements.push(Self::build_statement(inner)?);
                }
                _ => {}
            }
        }

        Ok(Strategy { name, parameters, statements })
    }

    fn build_strategy_declaration(pair: Pair<Rule>) -> Result<(String, HashMap<String, Value>)> {
        let mut inner = pair.into_inner();
        let name = inner.next()
            .and_then(|p| Self::extract_string(p.as_str()))
            .ok_or_else(|| anyhow!("Strategy name not found"))?;

        let mut params = HashMap::new();
        for param_pair in inner {
            if param_pair.as_rule() == Rule::parameter {
                let (key, value) = Self::build_parameter(param_pair)?;
                params.insert(key, value);
            }
        }

        Ok((name, params))
    }

    fn build_statement(pair: Pair<Rule>) -> Result<Statement> {
        let inner = pair.into_inner().next()
            .ok_or_else(|| anyhow!("Empty statement"))?;

        match inner.as_rule() {
            Rule::assignment => Self::build_assignment(inner),
            Rule::if_statement => Self::build_if_statement(inner),
            Rule::strategy_call => Self::build_strategy_call(inner),
            Rule::expression => Ok(Statement::Expression(Self::build_expression(inner)?)),
            _ => Err(anyhow!("Unknown statement type: {:?}", inner.as_rule()))
        }
    }

    fn build_assignment(pair: Pair<Rule>) -> Result<Statement> {
        let mut inner = pair.into_inner();

        let target_pair = inner.next()
            .ok_or_else(|| anyhow!("Assignment target not found"))?;

        let target = if target_pair.as_rule() == Rule::array_destructure {
            let vars = Self::build_array_destructure(target_pair)?;
            AssignmentTarget::ArrayDestructure(vars)
        } else {
            AssignmentTarget::Variable(target_pair.as_str().to_string())
        };

        let value = inner.next()
            .and_then(|p| Self::build_expression(p).ok())
            .ok_or_else(|| anyhow!("Assignment value not found"))?;

        Ok(Statement::Assignment { target, value })
    }

    fn build_expression(pair: Pair<Rule>) -> Result<Expression> {
        let inner = pair.into_inner();
        let mut parts: Vec<Pair<Rule>> = inner.collect();

        if parts.is_empty() {
            return Err(anyhow!("Empty expression"));
        }

        // å¤„ç†äºŒå…ƒè¿ç®—
        if parts.len() >= 3 {
            let left = Self::build_term(parts.remove(0))?;
            let mut current = left;

            while parts.len() >= 2 {
                let op_str = parts.remove(0).as_str();
                let right = Self::build_term(parts.remove(0))?;

                if let Some(op) = BinaryOperator::from_str(op_str) {
                    current = Expression::BinaryOp {
                        left: Box::new(current),
                        op,
                        right: Box::new(right),
                    };
                }
            }

            return Ok(current);
        }

        // å•ä¸ªterm
        Self::build_term(parts.into_iter().next().unwrap())
    }

    fn build_term(pair: Pair<Rule>) -> Result<Expression> {
        let inner = pair.into_inner().next();

        if inner.is_none() {
            // å¯èƒ½æ˜¯æ ‡è¯†ç¬¦æˆ–å­—é¢é‡
            return match pair.as_rule() {
                Rule::identifier => Ok(Expression::Variable(pair.as_str().to_string())),
                Rule::literal => Ok(Expression::Literal(Self::build_literal(pair)?)),
                _ => Err(anyhow!("Unknown term: {:?}", pair.as_rule()))
            };
        }

        let inner = inner.unwrap();
        match inner.as_rule() {
            Rule::literal => Ok(Expression::Literal(Self::build_literal(inner)?)),
            Rule::identifier => Ok(Expression::Variable(inner.as_str().to_string())),
            Rule::function_call => Self::build_function_call(inner),
            Rule::expression => Self::build_expression(inner),
            _ => Err(anyhow!("Unknown term type: {:?}", inner.as_rule()))
        }
    }

    fn build_function_call(pair: Pair<Rule>) -> Result<Expression> {
        let mut namespace = None;
        let mut name = String::new();
        let mut arguments = Vec::new();

        for inner in pair.into_inner() {
            match inner.as_rule() {
                Rule::namespace => namespace = Some(inner.as_str().to_string()),
                Rule::identifier => name = inner.as_str().to_string(),
                Rule::argument_list => {
                    for arg in inner.into_inner() {
                        arguments.push(Self::build_expression(arg)?);
                    }
                }
                _ => {}
            }
        }

        Ok(Expression::FunctionCall { namespace, name, arguments })
    }

    fn build_literal(pair: Pair<Rule>) -> Result<Value> {
        let inner = pair.into_inner().next()
            .ok_or_else(|| anyhow!("Empty literal"))?;

        match inner.as_rule() {
            Rule::integer_literal => {
                let val = inner.as_str().parse::<i64>()
                    .context("Failed to parse integer")?;
                Ok(Value::Integer(val))
            }
            Rule::float_literal => {
                let val = inner.as_str().parse::<f64>()
                    .context("Failed to parse float")?;
                Ok(Value::Float(val))
            }
            Rule::boolean_literal => {
                Ok(Value::Boolean(inner.as_str() == "true"))
            }
            Rule::string => {
                Ok(Value::String(Self::extract_string(inner.as_str())
                    .unwrap_or_default()))
            }
            _ => Err(anyhow!("Unknown literal type: {:?}", inner.as_rule()))
        }
    }

    fn extract_string(s: &str) -> Option<String> {
        if s.len() >= 2 && s.starts_with('"') && s.ends_with('"') {
            Some(s[1..s.len()-1].to_string())
        } else {
            None
        }
    }

    fn build_array_destructure(pair: Pair<Rule>) -> Result<Vec<String>> {
        let mut vars = Vec::new();
        for inner in pair.into_inner() {
            if inner.as_rule() == Rule::identifier {
                vars.push(inner.as_str().to_string());
            }
        }
        Ok(vars)
    }

    fn build_if_statement(pair: Pair<Rule>) -> Result<Statement> {
        let mut inner = pair.into_inner();

        let condition = inner.next()
            .and_then(|p| Self::build_expression(p).ok())
            .ok_or_else(|| anyhow!("If condition not found"))?;

        let then_block = inner.next()
            .map(|p| Self::build_block(p))
            .unwrap_or_else(|| Ok(Vec::new()))?;

        let else_block = inner.next()
            .and_then(|p| {
                if p.as_rule() == Rule::else_clause {
                    Some(Self::build_else_clause(p).ok()?)
                } else {
                    None
                }
            });

        Ok(Statement::If {
            condition,
            then_block,
            else_block,
        })
    }

    fn build_block(pair: Pair<Rule>) -> Result<Vec<Statement>> {
        let mut statements = Vec::new();
        for inner in pair.into_inner() {
            if inner.as_rule() == Rule::statement {
                statements.push(Self::build_statement(inner)?);
            }
        }
        Ok(statements)
    }

    fn build_else_clause(pair: Pair<Rule>) -> Result<Vec<Statement>> {
        for inner in pair.into_inner() {
            if inner.as_rule() == Rule::block {
                return Self::build_block(inner);
            }
        }
        Ok(Vec::new())
    }

    fn build_strategy_call(pair: Pair<Rule>) -> Result<Statement> {
        let mut function = String::new();
        let mut arguments = Vec::new();

        for inner in pair.into_inner() {
            match inner.as_rule() {
                Rule::identifier => function = inner.as_str().to_string(),
                Rule::argument_list => {
                    for arg in inner.into_inner() {
                        arguments.push(Self::build_expression(arg)?);
                    }
                }
                _ => {}
            }
        }

        Ok(Statement::StrategyCall { function, arguments })
    }

    fn build_parameter(pair: Pair<Rule>) -> Result<(String, Value)> {
        let mut inner = pair.into_inner();
        let key = inner.next()
            .map(|p| p.as_str().to_string())
            .ok_or_else(|| anyhow!("Parameter key not found"))?;
        let value = inner.next()
            .and_then(|p| Self::build_value(p).ok())
            .ok_or_else(|| anyhow!("Parameter value not found"))?;
        Ok((key, value))
    }

    fn build_value(pair: Pair<Rule>) -> Result<Value> {
        match pair.as_rule() {
            Rule::literal => Self::build_literal(pair),
            Rule::identifier => Ok(Value::String(pair.as_str().to_string())),
            _ => Err(anyhow!("Unknown value type: {:?}", pair.as_rule()))
        }
    }
}
```

### Step 3: ç¼–å†™ASTæµ‹è¯•

**æ–‡ä»¶: `tests/ast_test.rs`**

```rust
use trading_engine::strategy::ast_builder::ASTBuilder;
use trading_engine::strategy::ast::*;

#[test]
fn test_ast_simple_strategy() {
    let input = r#"
strategy("Test Strategy", overlay=true)
length = 20
sma_val = ta.sma(close, length)
"#;

    let ast = ASTBuilder::build(input).expect("Failed to build AST");

    assert_eq!(ast.name, "Test Strategy");
    assert_eq!(ast.parameters.get("overlay"), Some(&Value::Boolean(true)));
    assert_eq!(ast.statements.len(), 2);

    // éªŒè¯ç¬¬ä¸€ä¸ªèµ‹å€¼è¯­å¥
    match &ast.statements[0] {
        Statement::Assignment { target, value } => {
            assert_eq!(target, &AssignmentTarget::Variable("length".to_string()));
            assert_eq!(value, &Expression::Literal(Value::Integer(20)));
        }
        _ => panic!("Expected assignment statement"),
    }
}

#[test]
fn test_ast_function_call() {
    let input = r#"
strategy("Test")
sma_val = ta.sma(close, 20)
"#;

    let ast = ASTBuilder::build(input).expect("Failed to build AST");

    match &ast.statements[0] {
        Statement::Assignment { target: _, value } => {
            match value {
                Expression::FunctionCall { namespace, name, arguments } => {
                    assert_eq!(namespace, &Some("ta".to_string()));
                    assert_eq!(name, "sma");
                    assert_eq!(arguments.len(), 2);
                }
                _ => panic!("Expected function call expression"),
            }
        }
        _ => panic!("Expected assignment statement"),
    }
}

#[test]
fn test_ast_if_statement() {
    let input = r#"
strategy("Test")
if close > open
    strategy.entry("Long", strategy.long)
else
    strategy.close("Long")
"#;

    let ast = ASTBuilder::build(input).expect("Failed to build AST");

    match &ast.statements[0] {
        Statement::If { condition, then_block, else_block } => {
            // éªŒè¯æ¡ä»¶
            match condition {
                Expression::BinaryOp { op, .. } => {
                    assert_eq!(op, &BinaryOperator::Greater);
                }
                _ => panic!("Expected binary operation in condition"),
            }

            assert_eq!(then_block.len(), 1);
            assert!(else_block.is_some());
            assert_eq!(else_block.as_ref().unwrap().len(), 1);
        }
        _ => panic!("Expected if statement"),
    }
}

#[test]
fn test_ast_array_destructure() {
    let input = r#"
strategy("Test")
[middle, upper, lower] = ta.bb(close, 20, 2.0)
"#;

    let ast = ASTBuilder::build(input).expect("Failed to build AST");

    match &ast.statements[0] {
        Statement::Assignment { target, .. } => {
            match target {
                AssignmentTarget::ArrayDestructure(vars) => {
                    assert_eq!(vars, &vec![
                        "middle".to_string(),
                        "upper".to_string(),
                        "lower".to_string()
                    ]);
                }
                _ => panic!("Expected array destructure"),
            }
        }
        _ => panic!("Expected assignment statement"),
    }
}
```

### Step 4: è¿è¡ŒASTæµ‹è¯•

**å‘½ä»¤:**
```bash
cargo test test_ast
```

**æœŸæœ›è¾“å‡º:**
```
test tests::ast_test::test_ast_simple_strategy ... ok
test tests::ast_test::test_ast_function_call ... ok
test tests::ast_test::test_ast_if_statement ... ok
test tests::ast_test::test_ast_array_destructure ... ok
```

### Step 5: æäº¤ASTç”Ÿæˆå™¨

**å‘½ä»¤:**
```bash
git add src/strategy/ast.rs src/strategy/ast_builder.rs tests/ast_test.rs
git commit -m "feat: implement AST builder for Pine Script DSL"
```

---

## Task 4: åŸºç¡€æŠ€æœ¯æŒ‡æ ‡å®ç°

**Goal:** å®ç°Pine Scriptä¸­å¸¸ç”¨çš„æŠ€æœ¯æŒ‡æ ‡

**Files:**
- Create: `trading-engine/src/indicators/mod.rs` (æ‰©å±•)
- Create: `trading-engine/src/indicators/ma.rs`
- Create: `trading-engine/src/indicators/oscillators.rs`
- Create: `trading-engine/src/indicators/volatility.rs`
- Create: `tests/indicators_extended_test.rs`

### Step 1: å®ç°ç§»åŠ¨å¹³å‡æŒ‡æ ‡

**æ–‡ä»¶: `src/indicators/ma.rs`**

```rust
/// Simple Moving Average with epsilon handling
pub fn sma(data: &[f64], period: usize) -> Vec<f64> {
    if data.len() < period || period == 0 {
        return vec![];
    }

    let mut result = Vec::with_capacity(data.len() - period + 1);

    for i in period - 1..data.len() {
        let sum: f64 = data[i - period + 1..=i].iter().sum();
        result.push(sum / period as f64);
    }

    result
}

/// Exponential Moving Average
pub fn ema(data: &[f64], period: usize) -> Vec<f64> {
    if data.is_empty() || period == 0 {
        return vec![];
    }

    let mut result = Vec::with_capacity(data.len());
    let multiplier = 2.0 / (period as f64 + 1.0);

    // ç¬¬ä¸€ä¸ªEMAå€¼ä½¿ç”¨SMA
    if data.len() >= period {
        let first_sma: f64 = data[..period].iter().sum::<f64>() / period as f64;
        result.push(first_sma);

        for i in period..data.len() {
            let ema_val = (data[i] - result.last().unwrap()) * multiplier
                        + result.last().unwrap();
            result.push(ema_val);
        }
    }

    result
}

/// Weighted Moving Average
pub fn wma(data: &[f64], period: usize) -> Vec<f64> {
    if data.len() < period || period == 0 {
        return vec![];
    }

    let mut result = Vec::with_capacity(data.len() - period + 1);
    let weight_sum: f64 = (1..=period).sum::<usize>() as f64;

    for i in period - 1..data.len() {
        let mut weighted_sum = 0.0;
        for j in 0..period {
            weighted_sum += data[i - period + 1 + j] * (j + 1) as f64;
        }
        result.push(weighted_sum / weight_sum);
    }

    result
}

/// Volume Weighted Average Price
pub fn vwap(prices: &[f64], volumes: &[f64], period: usize) -> Vec<f64> {
    if prices.len() != volumes.len() || prices.len() < period {
        return vec![];
    }

    let mut result = Vec::with_capacity(prices.len() - period + 1);

    for i in period - 1..prices.len() {
        let mut price_volume_sum = 0.0;
        let mut volume_sum = 0.0;

        for j in i - period + 1..=i {
            price_volume_sum += prices[j] * volumes[j];
            volume_sum += volumes[j];
        }

        if volume_sum > 0.0 {
            result.push(price_volume_sum / volume_sum);
        } else {
            result.push(prices[i]); // fallback to current price
        }
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sma_calculation() {
        let data = vec![1.0, 2.0, 3.0, 4.0, 5.0];
        let sma = sma(&data, 3);
        assert_eq!(sma, vec![2.0, 3.0, 4.0]);
    }

    #[test]
    fn test_ema_calculation() {
        let data = vec![1.0, 2.0, 3.0, 4.0, 5.0];
        let ema = ema(&data, 3);
        assert!(ema.len() == 3);
        assert!((ema[0] - 2.0).abs() < 0.01);
    }

    #[test]
    fn test_wma_calculation() {
        let data = vec![1.0, 2.0, 3.0, 4.0, 5.0];
        let wma = wma(&data, 3);
        assert_eq!(wma.len(), 3);
        // WMA gives more weight to recent values
        assert!(wma[0] > 2.0); // Should be > simple average
    }
}
```

### Step 2: å®ç°éœ‡è¡æŒ‡æ ‡

**æ–‡ä»¶: `src/indicators/oscillators.rs`**

```rust
use super::ma::sma;

/// Relative Strength Index with Wilder's smoothing
pub fn rsi(data: &[f64], period: usize) -> Vec<f64> {
    if data.len() < period + 1 {
        return vec![];
    }

    let mut gains = Vec::new();
    let mut losses = Vec::new();

    // è®¡ç®—ä»·æ ¼å˜åŒ–
    for i in 1..data.len() {
        let change = data[i] - data[i - 1];
        if change > 0.0 {
            gains.push(change);
            losses.push(0.0);
        } else {
            gains.push(0.0);
            losses.push(change.abs());
        }
    }

    let mut result = Vec::new();

    // ç¬¬ä¸€ä¸ªRSIä½¿ç”¨ç®€å•å¹³å‡
    let avg_gain: f64 = gains[..period].iter().sum::<f64>() / period as f64;
    let avg_loss: f64 = losses[..period].iter().sum::<f64>() / period as f64;

    let rs = if avg_loss == 0.0 { 100.0 } else { avg_gain / avg_loss };
    result.push(100.0 - (100.0 / (1.0 + rs)));

    // åç»­RSIä½¿ç”¨Wilder'så¹³æ»‘
    let mut smoothed_gain = avg_gain;
    let mut smoothed_loss = avg_loss;

    for i in period..gains.len() {
        smoothed_gain = (smoothed_gain * (period - 1) as f64 + gains[i]) / period as f64;
        smoothed_loss = (smoothed_loss * (period - 1) as f64 + losses[i]) / period as f64;

        let rs = if smoothed_loss == 0.0 { 100.0 } else { smoothed_gain / smoothed_loss };
        result.push(100.0 - (100.0 / (1.0 + rs)));
    }

    result
}

/// Moving Average Convergence Divergence
pub fn macd(data: &[f64], fast: usize, slow: usize, signal: usize)
    -> (Vec<f64>, Vec<f64>, Vec<f64>) {

    if data.len() < slow {
        return (vec![], vec![], vec![]);
    }

    let ema_fast = super::ma::ema(data, fast);
    let ema_slow = super::ma::ema(data, slow);

    // Calculate MACD line
    let mut macd_line = Vec::new();
    let offset = slow - fast;
    for i in 0..ema_slow.len() {
        if i + offset < ema_fast.len() {
            macd_line.push(ema_fast[i + offset] - ema_slow[i]);
        }
    }

    // Calculate signal line
    let signal_line = super::ma::ema(&macd_line, signal);

    // Calculate histogram
    let mut histogram = Vec::new();
    let offset = signal - 1;
    for i in 0..signal_line.len() {
        if i + offset < macd_line.len() {
            histogram.push(macd_line[i + offset] - signal_line[i]);
        }
    }

    (macd_line, signal_line, histogram)
}

/// Stochastic Oscillator
pub fn stochastic(high: &[f64], low: &[f64], close: &[f64], period: usize, smooth_k: usize, smooth_d: usize)
    -> (Vec<f64>, Vec<f64>) {

    if high.len() != low.len() || high.len() != close.len() || high.len() < period {
        return (vec![], vec![]);
    }

    let mut raw_k = Vec::new();

    for i in period - 1..close.len() {
        let highest = high[i - period + 1..=i].iter()
            .fold(f64::NEG_INFINITY, |a, &b| a.max(b));
        let lowest = low[i - period + 1..=i].iter()
            .fold(f64::INFINITY, |a, &b| a.min(b));

        let range = highest - lowest;
        if range > 0.0 {
            raw_k.push(100.0 * (close[i] - lowest) / range);
        } else {
            raw_k.push(50.0); // Neutral value when no range
        }
    }

    // Smooth %K
    let k = sma(&raw_k, smooth_k);

    // Calculate %D
    let d = sma(&k, smooth_d);

    (k, d)
}

/// Commodity Channel Index
pub fn cci(high: &[f64], low: &[f64], close: &[f64], period: usize) -> Vec<f64> {
    if high.len() != low.len() || high.len() != close.len() || high.len() < period {
        return vec![];
    }

    // Calculate Typical Price
    let mut typical_price = Vec::with_capacity(high.len());
    for i in 0..high.len() {
        typical_price.push((high[i] + low[i] + close[i]) / 3.0);
    }

    let sma_tp = sma(&typical_price, period);
    let mut result = Vec::new();

    for i in 0..sma_tp.len() {
        let start = i + period - 1 - (period - 1);
        let end = i + period - 1 + 1;

        // Calculate Mean Deviation
        let mut sum_deviation = 0.0;
        for j in start..end.min(typical_price.len()) {
            sum_deviation += (typical_price[j] - sma_tp[i]).abs();
        }
        let mean_deviation = sum_deviation / period as f64;

        if mean_deviation > 0.0 {
            let cci_value = (typical_price[i + period - 1] - sma_tp[i]) / (0.015 * mean_deviation);
            result.push(cci_value);
        } else {
            result.push(0.0);
        }
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_rsi_calculation() {
        let data = vec![
            44.0, 44.25, 44.38, 44.5, 44.0,
            43.75, 44.25, 44.5, 44.75, 45.0,
            45.25, 45.5, 45.75, 46.0, 46.25
        ];

        let rsi_values = rsi(&data, 14);
        assert!(rsi_values.len() > 0);

        // RSI should be between 0 and 100
        for val in &rsi_values {
            assert!(*val >= 0.0 && *val <= 100.0);
        }
    }

    #[test]
    fn test_macd_calculation() {
        let data = vec![
            100.0, 101.0, 102.0, 101.5, 100.5,
            99.5, 100.0, 101.0, 102.5, 103.0,
            103.5, 104.0, 103.5, 103.0, 102.5,
            102.0, 102.5, 103.0, 103.5, 104.0,
            104.5, 105.0, 105.5, 106.0, 106.5
        ];

        let (macd_line, signal_line, histogram) = macd(&data, 12, 26, 9);

        assert!(macd_line.len() > 0);
        assert!(signal_line.len() > 0);
        assert!(histogram.len() > 0);
    }

    #[test]
    fn test_stochastic_calculation() {
        let high = vec![10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 14.0, 13.0, 12.0, 11.0];
        let low = vec![8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 12.0, 11.0, 10.0, 9.0];
        let close = vec![9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 13.0, 12.0, 11.0, 10.0];

        let (k, d) = stochastic(&high, &low, &close, 5, 3, 3);

        assert!(k.len() > 0);
        assert!(d.len() > 0);

        // Stochastic values should be between 0 and 100
        for val in &k {
            assert!(*val >= 0.0 && *val <= 100.0);
        }
    }
}
```

### Step 3: å®ç°æ³¢åŠ¨ç‡æŒ‡æ ‡

**æ–‡ä»¶: `src/indicators/volatility.rs`**

```rust
use super::ma::sma;

/// Bollinger Bands
pub fn bollinger_bands(data: &[f64], period: usize, std_dev_multiplier: f64)
    -> (Vec<f64>, Vec<f64>, Vec<f64>) {

    if data.len() < period {
        return (vec![], vec![], vec![]);
    }

    let middle = sma(data, period);
    let mut upper = Vec::with_capacity(middle.len());
    let mut lower = Vec::with_capacity(middle.len());

    for i in 0..middle.len() {
        // Calculate standard deviation
        let start = i + period - 1 - (period - 1);
        let end = i + period - 1 + 1;

        let slice = &data[start..end.min(data.len())];
        let mean = middle[i];

        let variance: f64 = slice.iter()
            .map(|&x| (x - mean).powi(2))
            .sum::<f64>() / period as f64;

        let std_dev = variance.sqrt();

        upper.push(mean + std_dev_multiplier * std_dev);
        lower.push(mean - std_dev_multiplier * std_dev);
    }

    (middle, upper, lower)
}

/// Average True Range
pub fn atr(high: &[f64], low: &[f64], close: &[f64], period: usize) -> Vec<f64> {
    if high.len() != low.len() || high.len() != close.len() || high.len() < period + 1 {
        return vec![];
    }

    let mut true_ranges = Vec::with_capacity(high.len() - 1);

    // Calculate True Range
    for i in 1..high.len() {
        let high_low = high[i] - low[i];
        let high_close = (high[i] - close[i - 1]).abs();
        let low_close = (low[i] - close[i - 1]).abs();

        true_ranges.push(high_low.max(high_close).max(low_close));
    }

    // Calculate ATR using Wilder's smoothing
    let mut atr_values = Vec::new();

    // First ATR is simple average
    let first_atr: f64 = true_ranges[..period].iter().sum::<f64>() / period as f64;
    atr_values.push(first_atr);

    // Subsequent ATR values use smoothing
    let mut current_atr = first_atr;
    for i in period..true_ranges.len() {
        current_atr = ((current_atr * (period - 1) as f64) + true_ranges[i]) / period as f64;
        atr_values.push(current_atr);
    }

    atr_values
}

/// Keltner Channels
pub fn keltner_channels(high: &[f64], low: &[f64], close: &[f64],
                        ema_period: usize, atr_period: usize, multiplier: f64)
    -> (Vec<f64>, Vec<f64>, Vec<f64>) {

    let middle = super::ma::ema(close, ema_period);
    let atr_values = atr(high, low, close, atr_period);

    if middle.is_empty() || atr_values.is_empty() {
        return (vec![], vec![], vec![]);
    }

    let min_len = middle.len().min(atr_values.len());
    let mut upper = Vec::with_capacity(min_len);
    let mut lower = Vec::with_capacity(min_len);

    for i in 0..min_len {
        upper.push(middle[i] + multiplier * atr_values[i]);
        lower.push(middle[i] - multiplier * atr_values[i]);
    }

    (middle[..min_len].to_vec(), upper, lower)
}

/// Standard Deviation
pub fn std_dev(data: &[f64], period: usize) -> Vec<f64> {
    if data.len() < period {
        return vec![];
    }

    let sma_values = sma(data, period);
    let mut result = Vec::with_capacity(sma_values.len());

    for i in 0..sma_values.len() {
        let start = i;
        let end = i + period;

        let slice = &data[start..end.min(data.len())];
        let mean = sma_values[i];

        let variance: f64 = slice.iter()
            .map(|&x| (x - mean).powi(2))
            .sum::<f64>() / period as f64;

        result.push(variance.sqrt());
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_bollinger_bands() {
        let data = vec![
            100.0, 101.0, 102.0, 101.5, 100.5,
            99.5, 100.0, 101.0, 102.5, 103.0
        ];

        let (middle, upper, lower) = bollinger_bands(&data, 5, 2.0);

        assert_eq!(middle.len(), upper.len());
        assert_eq!(middle.len(), lower.len());

        // Upper band should be above middle, lower below
        for i in 0..middle.len() {
            assert!(upper[i] > middle[i]);
            assert!(lower[i] < middle[i]);
        }
    }

    #[test]
    fn test_atr_calculation() {
        let high = vec![10.0, 11.0, 12.0, 13.0, 14.0, 15.0];
        let low = vec![8.0, 9.0, 10.0, 11.0, 12.0, 13.0];
        let close = vec![9.0, 10.0, 11.0, 12.0, 13.0, 14.0];

        let atr_values = atr(&high, &low, &close, 3);

        assert!(atr_values.len() > 0);

        // ATR should always be positive
        for val in &atr_values {
            assert!(*val > 0.0);
        }
    }

    #[test]
    fn test_keltner_channels() {
        let high = vec![10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 14.0, 13.0];
        let low = vec![8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 12.0, 11.0];
        let close = vec![9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 13.0, 12.0];

        let (middle, upper, lower) = keltner_channels(&high, &low, &close, 3, 3, 2.0);

        assert!(middle.len() > 0);
        assert_eq!(middle.len(), upper.len());
        assert_eq!(middle.len(), lower.len());

        // Channels should be properly ordered
        for i in 0..middle.len() {
            assert!(upper[i] > middle[i]);
            assert!(lower[i] < middle[i]);
        }
    }
}
```

### Step 4: æ›´æ–°indicatorsæ¨¡å—

**æ–‡ä»¶: `src/indicators/mod.rs`** (æ‰©å±•ç°æœ‰æ–‡ä»¶)

```rust
pub mod ma;
pub mod oscillators;
pub mod volatility;

// Re-export commonly used functions
pub use ma::{sma, ema, wma, vwap};
pub use oscillators::{rsi, macd, stochastic, cci};
pub use volatility::{bollinger_bands, atr, keltner_channels, std_dev};

// Keep existing epsilon and crossover functions
pub const EPSILON: f64 = 1e-8;

/// æ£€æµ‹å‘ä¸Šäº¤å‰
pub fn is_crossover(fast_prev: &f64, fast_curr: &f64, slow_prev: &f64, slow_curr: &f64) -> bool {
    fast_prev <= slow_prev && (fast_curr - slow_curr) > EPSILON
}

/// æ£€æµ‹å‘ä¸‹äº¤å‰
pub fn is_crossunder(fast_prev: &f64, fast_curr: &f64, slow_prev: &f64, slow_curr: &f64) -> bool {
    fast_prev >= slow_prev && (slow_curr - fast_curr) > EPSILON
}

/// Crossover detection for vectors
pub fn crossover(series1: &[f64], series2: &[f64]) -> Vec<bool> {
    if series1.len() != series2.len() || series1.len() < 2 {
        return vec![];
    }

    let mut result = vec![false]; // First element has no previous

    for i in 1..series1.len() {
        result.push(is_crossover(
            &series1[i-1], &series1[i],
            &series2[i-1], &series2[i]
        ));
    }

    result
}

/// Crossunder detection for vectors
pub fn crossunder(series1: &[f64], series2: &[f64]) -> Vec<bool> {
    if series1.len() != series2.len() || series1.len() < 2 {
        return vec![];
    }

    let mut result = vec![false]; // First element has no previous

    for i in 1..series1.len() {
        result.push(is_crossunder(
            &series1[i-1], &series1[i],
            &series2[i-1], &series2[i]
        ));
    }

    result
}
```

### Step 5: è¿è¡Œæ‰€æœ‰æŒ‡æ ‡æµ‹è¯•

**å‘½ä»¤:**
```bash
cargo test indicators
```

**æœŸæœ›è¾“å‡º:**
```
test indicators::ma::tests::test_sma_calculation ... ok
test indicators::ma::tests::test_ema_calculation ... ok
test indicators::ma::tests::test_wma_calculation ... ok
test indicators::oscillators::tests::test_rsi_calculation ... ok
test indicators::oscillators::tests::test_macd_calculation ... ok
test indicators::oscillators::tests::test_stochastic_calculation ... ok
test indicators::volatility::tests::test_bollinger_bands ... ok
test indicators::volatility::tests::test_atr_calculation ... ok
test indicators::volatility::tests::test_keltner_channels ... ok
```

### Step 6: æäº¤æŠ€æœ¯æŒ‡æ ‡å®ç°

**å‘½ä»¤:**
```bash
git add src/indicators/ tests/indicators_extended_test.rs
git commit -m "feat: implement comprehensive technical indicators library"
```

---

## éªŒæ”¶æ ‡å‡†

Phase 2å®Œæˆæ ‡å‡†ï¼š

- [ ] Pine Script DSLè§£æå™¨èƒ½è§£æç¤ºä¾‹ç­–ç•¥
- [ ] 15+æŠ€æœ¯æŒ‡æ ‡å®ç°å¹¶æµ‹è¯•é€šè¿‡
- [ ] ASTèƒ½æ­£ç¡®è¡¨ç¤ºæ‰€æœ‰æ”¯æŒçš„è¯­æ³•ç»“æ„
- [ ] ç­–ç•¥èƒ½ä»æ–‡ä»¶åŠ è½½å¹¶è§£æ
- [ ] æŒ‡æ ‡è®¡ç®—æ€§èƒ½è¾¾åˆ° <1ms/1000æ•°æ®ç‚¹
- [ ] Freqtradeç­–ç•¥è½¬æ¢å™¨åŸºç¡€æ¡†æ¶å®Œæˆ
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç‡ >90%
- [ ] æ–‡æ¡£å®Œæ•´ï¼ˆè¯­æ³•è§„èŒƒã€ä½¿ç”¨ç¤ºä¾‹ï¼‰

---

## ä¸‹ä¸€æ­¥

å®ŒæˆPhase 2åï¼Œç»§ç»­ï¼š
- **Phase 3**: ç›‘æ§ç³»ç»Ÿï¼ˆRedis/Timestreamé›†æˆã€Web Dashboardï¼‰
- **Phase 4**: ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²å’Œä¼˜åŒ–

---

**è®¡åˆ’åˆ›å»ºå®Œæˆï¼** ğŸ‰

è¯·ä½¿ç”¨ `superpowers:executing-plans` æ¥é€æ­¥å®æ–½æ­¤è®¡åˆ’ã€‚